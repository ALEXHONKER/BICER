package ca.uwaterloo.ece.bicer;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.junit.Test;
import ca.uwaterloo.ece.bicer.data.BIChange;
import ca.uwaterloo.ece.bicer.utils.Utils;

/*
 * This Java source file was auto generated by running 'gradle init --type java-library'
 * by 'j22nam' at '27/05/16 5:45 PM' with Gradle 2.13
 *
 * @author j22nam, @date 27/05/16 5:45 PM
 */
public class ResultValidationTest {
    @Test public void testSomeLibraryMethod() {
    	
    	String project ="projectName";
    	String dir = System.getProperty("user.home") + "/path/" + project +"/";
        
    	String pathForBIChanges = dir + "biChanges.txt";
    	String pathForBIChangesSanitized = dir + "biChangesSanitized.txt";
    	/* BI_SHA1 PATH    BIDATE  FixDAT
    	 * and
    	 * Noisy BI changes
    	 * BI_SHA1 PATH    BIDATE  FixDATE  DUE_TO isAddedLine   line
    	 */
    	String pathForBIChangesNoiseFiltered =  dir + "biChangesNoiseFiltered.txt"; 
    	String pathForBIManuallyVerified = dir + project + "BIs.txt";
    	
    	ArrayList<BIChange> biChanges = loadBIChanges(pathForBIChanges, true);
    	ArrayList<BIChange> biChangesSanitized = loadBIChanges(pathForBIChangesSanitized, false);
    	
    	if(biChanges.size()!=biChangesSanitized.size()){
    		System.err.println("FATAL: the number of changes must be same between the original and sanitized data");
    		System.exit(0);
    	}
    		
    	ArrayList<BIChange> biChangesNoiseFiltered = getBIChangesNoiseFiltered( Utils.getLines(pathForBIChangesNoiseFiltered, true));
    	ArrayList<String> biSha1AndPathManuallyVerified = getBISha1AndPath(Utils.getLines(pathForBIManuallyVerified, true));
    	
    	// match (2) (3)
    	ArrayList<Integer> correctBIChangeIndexAfterFiltering = new ArrayList<Integer>();
    	for(BIChange biChangeFiltered:biChangesNoiseFiltered){
    		for(BIChange biChageSanitized:biChangesSanitized){
    			
    			if(biChangeFiltered.equals(biChageSanitized)){
    				int index = biChangesSanitized.indexOf(biChageSanitized);
    				if(index<0){
    					System.err.println("FATAL: Error when matching biChangesSanitized and biChangesFiltered ");
    					System.exit(0);
    				}
    				correctBIChangeIndexAfterFiltering.add(index);
    			}
    		}
    	}
    	
    	// generate biSha1+path from none-sanitized but tool filtered data (1)
    	ArrayList<String> biSha1AndPathFromNoneSanitizedDataToolFiltered = new ArrayList<String>();
    	for(int i=0; i<correctBIChangeIndexAfterFiltering.size();i++){
    		BIChange biChange = biChanges.get(i);
    		biSha1AndPathFromNoneSanitizedDataToolFiltered.add(biChange.getBISha1()+ "\t" + biChange.getPath());
    	}
    	
    	// find FP and FN
    	Set<String> FPs = new HashSet<String>();
    	Set<String> FNs = new HashSet<String>();
    	Set<String> TPs1 = new HashSet<String>();
    	Set<String> TPs2 = new HashSet<String>();
    	
    	// find FPs
    	for(String key:biSha1AndPathFromNoneSanitizedDataToolFiltered){
    		if(biSha1AndPathManuallyVerified.contains(key))
    			TPs1.add(key);
    		else
    			FPs.add(key);
    	}
    	
    	//find TPs
    	for(String key:biSha1AndPathManuallyVerified){
    		if(biSha1AndPathFromNoneSanitizedDataToolFiltered.contains(key))
    			TPs2.add(key);
    		else
    			FNs.add(key);
    	}
    	
    	// sanity check: TP1 should be same as TP2
    	for(String key:TPs1)
    		if(!TPs2.contains(key)){
    			System.err.println("FATAL: TP1 and TP2 are not same ");
				System.exit(0);
    		}
    	
    	System.out.println("# real BIs: " + biSha1AndPathManuallyVerified.size());
    	System.out.println("# TP BIs: " + TPs1.size());
    	System.out.println("# FN BIs: " + FNs.size());
    	System.out.println("TP+FN=" + (TPs1.size()+FNs.size()) + " This should be same as # real BIs=" + biSha1AndPathManuallyVerified.size());
    	System.out.println("# FP BIs: " + FPs.size());
    	
    	
    	System.out.println("\n\nFalse Negatives that must not be filtered!");
    	
    	for(String FN:FNs){
    		System.out.println("+ " + FN);
    	}

    	ArrayList<BIChange> identifiedAsNoise = getBIChangesIdentifiedAsNoise(Utils.getLines(pathForBIChangesNoiseFiltered, true));
    	for(BIChange noisyBiChange:identifiedAsNoise){
    		int indexFromSenitizedBIs = findBIChange(biChangesSanitized,noisyBiChange);
    		BIChange originalBIChange = biChanges.get(indexFromSenitizedBIs);
    		String key = originalBIChange.getBISha1() + "\t" + originalBIChange.getPath();
    		if(FNs.contains(key))
    			System.out.println("FN (this must not be filtered but filtered): " + noisyBiChange.getFilteredDueTo() + "\t" + originalBIChange.getRecord());
    	}
    	
    	System.out.println("\n\nFalse Positives that should be filtered!");
    	
    	for(String FP:FPs){
    		System.out.println("- " + FP);
    	}
    	
    	for(BIChange biChangeAliveAfterFiltering:biChangesNoiseFiltered){
    		int indexFromSenitizedBIs = findBIChange(biChangesSanitized,biChangeAliveAfterFiltering);
    		BIChange originalBIChange = biChanges.get(indexFromSenitizedBIs);
    		String key = originalBIChange.getBISha1() + "\t" + originalBIChange.getPath();
    		if(FPs.contains(key))
    			System.out.println("FP (this must be filtered but did not): " +  originalBIChange.getRecord());
    	}
    }
    
    private int findBIChange(ArrayList<BIChange> biChangesSanitized, BIChange noisyBiChange) {
		
    	for(BIChange biChange:biChangesSanitized){
    		if(biChange.equals(noisyBiChange))
    			return biChangesSanitized.indexOf(biChange);
    	}
    	
		return -1;
	}

	private ArrayList<String> getBISha1AndPath(ArrayList<String> lines) {
    	ArrayList<String> keys = new ArrayList<String>();
    	
    	for(String line:lines){
    		keys.add(line);
    	}
    	
		return keys;
	}

	private ArrayList<BIChange> getBIChangesNoiseFiltered(ArrayList<String> linesForbiChangesNoiseFiltered) {
		ArrayList<BIChange> biChangesNoiseFiltered = new ArrayList<BIChange>();
		
		for(String line:linesForbiChangesNoiseFiltered){
			if(line.trim().equals(""))
				break;
			
			BIChange biChange = new BIChange(line,false);
			biChangesNoiseFiltered.add(biChange);
		}
		return biChangesNoiseFiltered;
	}

	private ArrayList<BIChange> loadBIChanges(String path,boolean forSanitizer) {
		ArrayList<String> BIChangeInfo = Utils.getLines(path, true); // Sanitizer file does not have header line, so remove it.
		ArrayList<BIChange> biChanges = new ArrayList<BIChange>();
		for(String info: BIChangeInfo){
			biChanges.add(new BIChange(info,forSanitizer));
		}
		
		return biChanges;
	}
	
	private ArrayList<BIChange> getBIChangesIdentifiedAsNoise(ArrayList<String> linesForbiChangesNoiseFiltered) {
		ArrayList<BIChange> biChangesIdentifiedAsNoise = new ArrayList<BIChange>();

		boolean ready = false;
		for(String line:linesForbiChangesNoiseFiltered){
			
			if(line.trim().equals("BI_SHA1	PATH	BIDATE	FixDATE	 DUE_TO")){
					ready=true;
					continue;
			}
			
			if(ready){
				BIChange biChange = new BIChange(line,false);
				
				biChange.setFilteredDueTo(line.split("\t")[10]);
				biChangesIdentifiedAsNoise.add(biChange);
			}
		}
		return biChangesIdentifiedAsNoise;
	}
}
